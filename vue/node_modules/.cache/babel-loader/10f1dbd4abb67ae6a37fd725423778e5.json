{"ast":null,"code":"import { defineComponent, ref, reactive, computed, unref, watch, onMounted, onBeforeUnmount, h, withModifiers } from 'vue';\nimport { isClient } from '@vueuse/core';\nimport '../../../scrollbar/index.mjs';\nimport '../../../../utils/index.mjs';\nimport { HORIZONTAL, ScrollbarDirKey, SCROLLBAR_MIN_SIZE } from '../defaults.mjs';\nimport { virtualizedScrollbarProps } from '../props.mjs';\nimport { renderThumbStyle } from '../utils.mjs';\nimport { BAR_MAP } from '../../../scrollbar/src/util.mjs';\nimport { on, off } from '../../../../utils/dom/event.mjs';\nimport { cAF, rAF } from '../../../../utils/raf.mjs';\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: virtualizedScrollbarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n\n  setup(props, {\n    emit\n  }) {\n    const GAP = 4;\n    const trackRef = ref();\n    const thumbRef = ref();\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackSize = computed(() => props.clientSize - GAP);\n    const trackStyle = computed(() => ({\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? `${trackSize.value}px` : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : `${trackSize.value}px`,\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      const ratio = props.ratio;\n      const clientSize = props.clientSize;\n\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (ratio >= 50) {\n        return ratio * clientSize / 100;\n      }\n\n      const SCROLLBAR_MAX_SIZE = clientSize / 3;\n      return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - GAP));\n\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      onselectstartStore = document.onselectstart;\n\n      document.onselectstart = () => false;\n\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    const onThumbMouseDown = e => {\n      e.stopImmediatePropagation();\n\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n\n    const onMouseMove = e => {\n      const {\n        isDragging\n      } = state;\n      if (!isDragging) return;\n      if (!thumbRef.value || !trackRef.value) return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n\n    const clickTrackHandler = e => {\n      const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);\n      const thumbHalf = thumbRef.value[bar.value.offset] / 2;\n      const distance = offset - thumbHalf;\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n      emit(\"scroll\", distance, totalSteps.value);\n    };\n\n    const onScrollbarTouchStart = e => e.preventDefault();\n\n    watch(() => props.scrollFrom, v => {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * totalSteps.value);\n    });\n    onMounted(() => {\n      if (!isClient) return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(clickTrackHandler, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, []));\n    };\n  }\n\n});\nexport { ScrollBar as default };","map":null,"metadata":{},"sourceType":"module"}