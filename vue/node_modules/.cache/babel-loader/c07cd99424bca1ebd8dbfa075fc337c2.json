{"ast":null,"code":"import { defineComponent, ref, provide, unref, onMounted, nextTick, watch, onBeforeUnmount, renderSlot } from 'vue';\nimport '../../../constants/index.mjs';\nimport { getEdges, tryFocus, focusableStack, focusFirstDescendant, obtainAllFocusableElements } from './utils.mjs';\nimport { ON_MOUNT_FOCUS_EVT, ON_UNMOUNT_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_ON_MOUNT, FOCUS_ON_MOUNT_OPTS, FOCUS_ON_UNMOUNT } from './tokens.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean\n  },\n  emits: [ON_MOUNT_FOCUS_EVT, ON_UNMOUNT_FOCUS_EVT],\n\n  setup(props, {\n    emit\n  }) {\n    const focusTrapRef = ref();\n    const forwardRef = ref(null);\n    let lastFocusBeforeMounted;\n    let lastFocusAfterMounted;\n    const focusLayer = {\n      paused: false,\n\n      pause() {\n        this.paused = true;\n      },\n\n      resume() {\n        this.paused = false;\n      }\n\n    };\n\n    const onKeydown = e => {\n      if (!props.loop && !props.trapped) return;\n      if (focusLayer.paused) return;\n      const {\n        key,\n        altKey,\n        ctrlKey,\n        metaKey,\n        currentTarget,\n        shiftKey\n      } = e;\n      const {\n        loop\n      } = props;\n      const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      const currentFocusingEl = document.activeElement;\n\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget;\n        const [first, last] = getEdges(container);\n        const isTabbable = first && last;\n\n        if (!isTabbable) {\n          if (currentFocusingEl === container) e.preventDefault();\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault();\n            if (loop) tryFocus(first, true);\n          } else if (shiftKey && currentFocusingEl === first) {\n            e.preventDefault();\n            if (loop) tryFocus(last, true);\n          }\n        }\n      }\n    };\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown\n    });\n\n    const focusOnMount = e => {\n      emit(ON_MOUNT_FOCUS_EVT, e);\n    };\n\n    const focusOnUnmount = e => emit(ON_UNMOUNT_FOCUS_EVT, e);\n\n    const onFocusIn = e => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      const target = e.target;\n\n      if (target && trapContainer.contains(target)) {\n        lastFocusAfterMounted = target;\n      } else {\n        tryFocus(lastFocusAfterMounted, true);\n      }\n    };\n\n    const onFocusOut = e => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n\n      if (!trapContainer.contains(e.relatedTarget)) {\n        tryFocus(lastFocusAfterMounted, true);\n      }\n    };\n\n    const cleanupDocumentListeners = () => {\n      document.removeEventListener(\"focusin\", onFocusIn);\n      document.removeEventListener(\"focusout\", onFocusOut);\n    };\n\n    onMounted(() => {\n      const trapContainer = unref(forwardRef);\n\n      if (trapContainer) {\n        focusableStack.push(focusLayer);\n        const prevFocusedElement = document.activeElement;\n        lastFocusBeforeMounted = prevFocusedElement;\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n\n        if (!isPrevFocusContained) {\n          const mountEvent = new Event(FOCUS_ON_MOUNT, FOCUS_ON_MOUNT_OPTS);\n          trapContainer.addEventListener(FOCUS_ON_MOUNT, focusOnMount);\n          trapContainer.dispatchEvent(mountEvent);\n\n          if (!mountEvent.defaultPrevented) {\n            nextTick(() => {\n              focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);\n\n              if (document.activeElement === prevFocusedElement) {\n                tryFocus(trapContainer);\n              }\n            });\n          }\n        }\n      }\n\n      watch(() => props.trapped, trapped => {\n        if (trapped) {\n          document.addEventListener(\"focusin\", onFocusIn);\n          document.addEventListener(\"focusout\", onFocusOut);\n        } else {\n          cleanupDocumentListeners();\n        }\n      }, {\n        immediate: true\n      });\n    });\n    onBeforeUnmount(() => {\n      cleanupDocumentListeners();\n      const trapContainer = unref(forwardRef);\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_ON_MOUNT, focusOnMount);\n        const unmountEvent = new Event(FOCUS_ON_UNMOUNT, FOCUS_ON_MOUNT_OPTS);\n        trapContainer.addEventListener(FOCUS_ON_UNMOUNT, focusOnUnmount);\n        trapContainer.dispatchEvent(unmountEvent);\n\n        if (!unmountEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeMounted != null ? lastFocusBeforeMounted : document.body, true);\n        }\n\n        trapContainer.removeEventListener(FOCUS_ON_UNMOUNT, focusOnMount);\n        focusableStack.remove(focusLayer);\n      }\n    });\n    return {\n      focusTrapRef,\n      forwardRef,\n      onKeydown\n    };\n  }\n\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\");\n}\n\nvar ElFocusTrap = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { ElFocusTrap as default };","map":null,"metadata":{},"sourceType":"module"}