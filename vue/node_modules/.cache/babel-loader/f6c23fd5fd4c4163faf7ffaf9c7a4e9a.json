{"ast":null,"code":"import { ref, computed, defineComponent, watch, reactive, toRefs, provide, openBlock, createElementBlock, normalizeClass, renderSlot } from 'vue';\nimport '../../../tokens/index.mjs';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport { useSize } from '../../../hooks/use-common-props/index.mjs';\nimport { elFormKey } from '../../../tokens/form.mjs';\n\nfunction useFormLabelWidth() {\n  const potentialLabelWidthArr = ref([]);\n  const autoLabelWidth = computed(() => {\n    if (!potentialLabelWidthArr.value.length) return \"0\";\n    const max = Math.max(...potentialLabelWidthArr.value);\n    return max ? `${max}px` : \"\";\n  });\n\n  function getLabelWidthIndex(width) {\n    const index = potentialLabelWidthArr.value.indexOf(width);\n\n    if (index === -1) {\n      debugWarn(\"Form\", `unexpected width ${width}`);\n    }\n\n    return index;\n  }\n\n  function registerLabelWidth(val, oldVal) {\n    if (val && oldVal) {\n      const index = getLabelWidthIndex(oldVal);\n      potentialLabelWidthArr.value.splice(index, 1, val);\n    } else if (val) {\n      potentialLabelWidthArr.value.push(val);\n    }\n  }\n\n  function deregisterLabelWidth(val) {\n    const index = getLabelWidthIndex(val);\n    index > -1 && potentialLabelWidthArr.value.splice(index, 1);\n  }\n\n  return {\n    autoLabelWidth,\n    registerLabelWidth,\n    deregisterLabelWidth\n  };\n}\n\nconst _sfc_main = defineComponent({\n  name: \"ElForm\",\n  props: {\n    model: Object,\n    rules: Object,\n    labelPosition: String,\n    labelWidth: {\n      type: [String, Number],\n      default: \"\"\n    },\n    labelSuffix: {\n      type: String,\n      default: \"\"\n    },\n    inline: Boolean,\n    inlineMessage: Boolean,\n    statusIcon: Boolean,\n    showMessage: {\n      type: Boolean,\n      default: true\n    },\n    size: String,\n    disabled: Boolean,\n    validateOnRuleChange: {\n      type: Boolean,\n      default: true\n    },\n    hideRequiredAsterisk: {\n      type: Boolean,\n      default: false\n    },\n    scrollToError: Boolean\n  },\n  emits: [\"validate\"],\n\n  setup(props, {\n    emit\n  }) {\n    const fields = [];\n    watch(() => props.rules, () => {\n      fields.forEach(field => {\n        field.evaluateValidationEnabled();\n      });\n\n      if (props.validateOnRuleChange) {\n        validate(() => ({}));\n      }\n    });\n    const formSize = useSize();\n    const prefix = \"el-form\";\n    const formKls = computed(() => {\n      const {\n        labelPosition,\n        inline\n      } = props;\n      return [prefix, `${prefix}--${formSize.value}`, labelPosition ? `${prefix}--label-${labelPosition}` : \"\", inline ? `${prefix}--inline` : \"\"];\n    });\n\n    const addField = field => {\n      if (field) {\n        fields.push(field);\n      }\n    };\n\n    const removeField = field => {\n      if (field.prop) {\n        fields.splice(fields.indexOf(field), 1);\n      }\n    };\n\n    const resetFields = () => {\n      if (!props.model) {\n        debugWarn(\"Form\", \"model is required for resetFields to work.\");\n        return;\n      }\n\n      fields.forEach(field => {\n        field.resetField();\n      });\n    };\n\n    const clearValidate = (props2 = []) => {\n      const fds = props2.length ? typeof props2 === \"string\" ? fields.filter(field => props2 === field.prop) : fields.filter(field => props2.indexOf(field.prop) > -1) : fields;\n      fds.forEach(field => {\n        field.clearValidate();\n      });\n    };\n\n    const validate = callback => {\n      if (!props.model) {\n        debugWarn(\"Form\", \"model is required for validate to work!\");\n        return;\n      }\n\n      let promise;\n\n      if (typeof callback !== \"function\") {\n        promise = new Promise((resolve, reject) => {\n          callback = function (valid2, invalidFields2) {\n            if (valid2) {\n              resolve(true);\n            } else {\n              reject(invalidFields2);\n            }\n          };\n        });\n      }\n\n      if (fields.length === 0) {\n        callback(true);\n      }\n\n      let valid = true;\n      let count = 0;\n      let invalidFields = {};\n      let firstInvalidFields;\n\n      for (const field of fields) {\n        field.validate(\"\", (message, field2) => {\n          if (message) {\n            valid = false;\n            firstInvalidFields || (firstInvalidFields = field2);\n          }\n\n          invalidFields = { ...invalidFields,\n            ...field2\n          };\n\n          if (++count === fields.length) {\n            callback(valid, invalidFields);\n          }\n        });\n      }\n\n      if (!valid && props.scrollToError) {\n        scrollToField(Object.keys(firstInvalidFields)[0]);\n      }\n\n      return promise;\n    };\n\n    const validateField = (props2, cb) => {\n      props2 = [].concat(props2);\n      const fds = fields.filter(field => props2.indexOf(field.prop) !== -1);\n\n      if (!fields.length) {\n        debugWarn(\"Form\", \"please pass correct props!\");\n        return;\n      }\n\n      fds.forEach(field => {\n        field.validate(\"\", cb);\n      });\n    };\n\n    const scrollToField = prop => {\n      fields.forEach(item => {\n        var _a, _b;\n\n        if (item.prop === prop) {\n          (_b = (_a = item.$el).scrollIntoView) == null ? void 0 : _b.call(_a);\n        }\n      });\n    };\n\n    const elForm = reactive({ ...toRefs(props),\n      resetFields,\n      clearValidate,\n      validateField,\n      emit,\n      addField,\n      removeField,\n      ...useFormLabelWidth()\n    });\n    provide(elFormKey, elForm);\n    return {\n      formKls,\n      validate,\n      resetFields,\n      clearValidate,\n      validateField,\n      scrollToField\n    };\n  }\n\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"form\", {\n    class: normalizeClass(_ctx.formKls)\n  }, [renderSlot(_ctx.$slots, \"default\")], 2);\n}\n\nvar Form = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { Form as default };","map":null,"metadata":{},"sourceType":"module"}