{"ast":null,"code":"import { defineComponent, getCurrentInstance, ref, shallowRef, computed, nextTick, watch, onMounted, onUpdated, resolveComponent, withDirectives, openBlock, createElementBlock, normalizeClass, normalizeStyle, createCommentVNode, Fragment, renderSlot, createElementVNode, mergeProps, createBlock, withCtx, resolveDynamicComponent, withModifiers, createVNode, toDisplayString, vShow } from 'vue';\nimport { isClient } from '@vueuse/core';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { CircleClose, View } from '@element-plus/icons-vue';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport '../../../constants/index.mjs';\nimport { calcTextareaHeight } from './calc-textarea-height.mjs';\nimport { inputProps, inputEmits } from './input.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useAttrs } from '../../../hooks/use-attrs/index.mjs';\nimport { useFormItem } from '../../../hooks/use-form-item/index.mjs';\nimport { useSize, useDisabled } from '../../../hooks/use-common-props/index.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { ValidateComponentsMap } from '../../../utils/vue/icon.mjs';\nimport { isObject } from '@vue/shared';\nimport { UPDATE_MODEL_EVENT } from '../../../constants/event.mjs';\nimport { isKorean } from '../../../utils/i18n.mjs';\nconst PENDANT_MAP = {\n  suffix: \"append\",\n  prefix: \"prepend\"\n};\n\nconst _sfc_main = defineComponent({\n  name: \"ElInput\",\n  components: {\n    ElIcon,\n    CircleClose,\n    IconView: View\n  },\n  inheritAttrs: false,\n  props: inputProps,\n  emits: inputEmits,\n\n  setup(props, {\n    slots,\n    emit,\n    attrs: rawAttrs\n  }) {\n    const instance = getCurrentInstance();\n    const attrs = useAttrs();\n    const {\n      form,\n      formItem\n    } = useFormItem();\n    const inputSize = useSize();\n    const inputDisabled = useDisabled();\n    const nsInput = useNamespace(\"input\");\n    const nsTextarea = useNamespace(\"textarea\");\n    const input = ref();\n    const textarea = ref();\n    const focused = ref(false);\n    const hovering = ref(false);\n    const isComposing = ref(false);\n    const passwordVisible = ref(false);\n\n    const _textareaCalcStyle = shallowRef(props.inputStyle);\n\n    const inputOrTextarea = computed(() => input.value || textarea.value);\n    const needStatusIcon = computed(() => {\n      var _a;\n\n      return (_a = form == null ? void 0 : form.statusIcon) != null ? _a : false;\n    });\n    const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || \"\");\n    const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);\n    const containerStyle = computed(() => rawAttrs.style);\n    const computedTextareaStyle = computed(() => [props.inputStyle, _textareaCalcStyle.value, {\n      resize: props.resize\n    }]);\n    const nativeInputValue = computed(() => props.modelValue === null || props.modelValue === void 0 ? \"\" : String(props.modelValue));\n    const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (focused.value || hovering.value));\n    const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && (!!nativeInputValue.value || focused.value));\n    const isWordLimitVisible = computed(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === \"text\" || props.type === \"textarea\") && !inputDisabled.value && !props.readonly && !props.showPassword);\n    const textLength = computed(() => Array.from(nativeInputValue.value).length);\n    const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));\n\n    const resizeTextarea = () => {\n      const {\n        type,\n        autosize\n      } = props;\n      if (!isClient || type !== \"textarea\") return;\n\n      if (autosize) {\n        const minRows = isObject(autosize) ? autosize.minRows : void 0;\n        const maxRows = isObject(autosize) ? autosize.maxRows : void 0;\n        _textareaCalcStyle.value = { ...calcTextareaHeight(textarea.value, minRows, maxRows)\n        };\n      } else {\n        _textareaCalcStyle.value = {\n          minHeight: calcTextareaHeight(textarea.value).minHeight\n        };\n      }\n    };\n\n    const setNativeInputValue = () => {\n      const input2 = inputOrTextarea.value;\n      if (!input2 || input2.value === nativeInputValue.value) return;\n      input2.value = nativeInputValue.value;\n    };\n\n    const calcIconOffset = place => {\n      const {\n        el\n      } = instance.vnode;\n      if (!el) return;\n      const elList = Array.from(el.querySelectorAll(`.${nsInput.e(place)}`));\n      const target = elList.find(item => item.parentNode === el);\n      if (!target) return;\n      const pendant = PENDANT_MAP[place];\n\n      if (slots[pendant]) {\n        target.style.transform = `translateX(${place === \"suffix\" ? \"-\" : \"\"}${el.querySelector(`.${nsInput.be(\"group\", pendant)}`).offsetWidth}px)`;\n      } else {\n        target.removeAttribute(\"style\");\n      }\n    };\n\n    const updateIconOffset = () => {\n      calcIconOffset(\"prefix\");\n      calcIconOffset(\"suffix\");\n    };\n\n    const handleInput = event => {\n      const {\n        value\n      } = event.target;\n      if (isComposing.value) return;\n      if (value === nativeInputValue.value) return;\n      emit(UPDATE_MODEL_EVENT, value);\n      emit(\"input\", value);\n      nextTick(setNativeInputValue);\n    };\n\n    const handleChange = event => {\n      emit(\"change\", event.target.value);\n    };\n\n    const focus = () => {\n      nextTick(() => {\n        var _a;\n\n        (_a = inputOrTextarea.value) == null ? void 0 : _a.focus();\n      });\n    };\n\n    const blur = () => {\n      var _a;\n\n      (_a = inputOrTextarea.value) == null ? void 0 : _a.blur();\n    };\n\n    const handleFocus = event => {\n      focused.value = true;\n      emit(\"focus\", event);\n    };\n\n    const handleBlur = event => {\n      var _a;\n\n      focused.value = false;\n      emit(\"blur\", event);\n\n      if (props.validateEvent) {\n        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, \"blur\");\n      }\n    };\n\n    const select = () => {\n      var _a;\n\n      (_a = inputOrTextarea.value) == null ? void 0 : _a.select();\n    };\n\n    const handleCompositionStart = event => {\n      emit(\"compositionstart\", event);\n      isComposing.value = true;\n    };\n\n    const handleCompositionUpdate = event => {\n      var _a;\n\n      emit(\"compositionupdate\", event);\n      const text = (_a = event.target) == null ? void 0 : _a.value;\n      const lastCharacter = text[text.length - 1] || \"\";\n      isComposing.value = !isKorean(lastCharacter);\n    };\n\n    const handleCompositionEnd = event => {\n      emit(\"compositionend\", event);\n\n      if (isComposing.value) {\n        isComposing.value = false;\n        handleInput(event);\n      }\n    };\n\n    const clear = () => {\n      emit(UPDATE_MODEL_EVENT, \"\");\n      emit(\"change\", \"\");\n      emit(\"clear\");\n      emit(\"input\", \"\");\n    };\n\n    const handlePasswordVisible = () => {\n      passwordVisible.value = !passwordVisible.value;\n      focus();\n    };\n\n    const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);\n    watch(() => props.modelValue, () => {\n      var _a;\n\n      nextTick(resizeTextarea);\n\n      if (props.validateEvent) {\n        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, \"change\");\n      }\n    });\n    watch(nativeInputValue, () => setNativeInputValue());\n    watch(() => props.type, () => {\n      nextTick(() => {\n        setNativeInputValue();\n        resizeTextarea();\n        updateIconOffset();\n      });\n    });\n    onMounted(() => {\n      setNativeInputValue();\n      updateIconOffset();\n      nextTick(resizeTextarea);\n    });\n    onUpdated(() => {\n      nextTick(updateIconOffset);\n    });\n\n    const onMouseLeave = evt => {\n      hovering.value = false;\n      emit(\"mouseleave\", evt);\n    };\n\n    const onMouseEnter = evt => {\n      hovering.value = true;\n      emit(\"mouseenter\", evt);\n    };\n\n    const handleKeydown = evt => {\n      emit(\"keydown\", evt);\n    };\n\n    return {\n      input,\n      textarea,\n      attrs,\n      inputSize,\n      validateState,\n      validateIcon,\n      containerStyle,\n      computedTextareaStyle,\n      inputDisabled,\n      showClear,\n      showPwdVisible,\n      isWordLimitVisible,\n      textLength,\n      hovering,\n      inputExceed,\n      passwordVisible,\n      inputOrTextarea,\n      suffixVisible,\n      needStatusIcon,\n      resizeTextarea,\n      handleInput,\n      handleChange,\n      handleFocus,\n      handleBlur,\n      handleCompositionStart,\n      handleCompositionUpdate,\n      handleCompositionEnd,\n      handlePasswordVisible,\n      clear,\n      select,\n      focus,\n      blur,\n      onMouseLeave,\n      onMouseEnter,\n      handleKeydown,\n      nsInput,\n      nsTextarea\n    };\n  }\n\n});\n\nconst _hoisted_1 = [\"type\", \"disabled\", \"readonly\", \"autocomplete\", \"tabindex\", \"aria-label\", \"placeholder\"];\nconst _hoisted_2 = [\"tabindex\", \"disabled\", \"readonly\", \"autocomplete\", \"aria-label\", \"placeholder\"];\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_el_icon = resolveComponent(\"el-icon\");\n\n  const _component_circle_close = resolveComponent(\"circle-close\");\n\n  const _component_icon_view = resolveComponent(\"icon-view\");\n\n  return withDirectives((openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass([_ctx.type === \"textarea\" ? _ctx.nsTextarea.b() : _ctx.nsInput.b(), _ctx.nsInput.m(_ctx.inputSize), _ctx.nsInput.is(\"disabled\", _ctx.inputDisabled), _ctx.nsInput.is(\"exceed\", _ctx.inputExceed), {\n      [_ctx.nsInput.b(\"group\")]: _ctx.$slots.prepend || _ctx.$slots.append,\n      [_ctx.nsInput.bm(\"group\", \"append\")]: _ctx.$slots.append,\n      [_ctx.nsInput.bm(\"group\", \"prepend\")]: _ctx.$slots.prepend,\n      [_ctx.nsInput.m(\"prefix\")]: _ctx.$slots.prefix || _ctx.prefixIcon,\n      [_ctx.nsInput.m(\"suffix\")]: _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,\n      [_ctx.nsInput.m(\"suffix--password-clear\")]: _ctx.showClear && _ctx.showPwdVisible\n    }, _ctx.$attrs.class]),\n    style: normalizeStyle(_ctx.containerStyle),\n    onMouseenter: _cache[17] || (_cache[17] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),\n    onMouseleave: _cache[18] || (_cache[18] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))\n  }, [createCommentVNode(\" input \"), _ctx.type !== \"textarea\" ? (openBlock(), createElementBlock(Fragment, {\n    key: 0\n  }, [createCommentVNode(\" prepend slot \"), _ctx.$slots.prepend ? (openBlock(), createElementBlock(\"div\", {\n    key: 0,\n    class: normalizeClass(_ctx.nsInput.be(\"group\", \"prepend\"))\n  }, [renderSlot(_ctx.$slots, \"prepend\")], 2)) : createCommentVNode(\"v-if\", true), createElementVNode(\"input\", mergeProps({\n    ref: \"input\",\n    class: _ctx.nsInput.e(\"inner\")\n  }, _ctx.attrs, {\n    type: _ctx.showPassword ? _ctx.passwordVisible ? \"text\" : \"password\" : _ctx.type,\n    disabled: _ctx.inputDisabled,\n    readonly: _ctx.readonly,\n    autocomplete: _ctx.autocomplete,\n    tabindex: _ctx.tabindex,\n    \"aria-label\": _ctx.label,\n    placeholder: _ctx.placeholder,\n    style: _ctx.inputStyle,\n    onCompositionstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),\n    onCompositionupdate: _cache[1] || (_cache[1] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),\n    onCompositionend: _cache[2] || (_cache[2] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),\n    onInput: _cache[3] || (_cache[3] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),\n    onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),\n    onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),\n    onChange: _cache[6] || (_cache[6] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),\n    onKeydown: _cache[7] || (_cache[7] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))\n  }), null, 16, _hoisted_1), createCommentVNode(\" prefix slot \"), _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock(\"span\", {\n    key: 1,\n    class: normalizeClass(_ctx.nsInput.e(\"prefix\"))\n  }, [createElementVNode(\"span\", {\n    class: normalizeClass(_ctx.nsInput.e(\"prefix-inner\"))\n  }, [renderSlot(_ctx.$slots, \"prefix\"), _ctx.prefixIcon ? (openBlock(), createBlock(_component_el_icon, {\n    key: 0,\n    class: normalizeClass(_ctx.nsInput.e(\"icon\"))\n  }, {\n    default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))]),\n    _: 1\n  }, 8, [\"class\"])) : createCommentVNode(\"v-if\", true)], 2)], 2)) : createCommentVNode(\"v-if\", true), createCommentVNode(\" suffix slot \"), _ctx.suffixVisible ? (openBlock(), createElementBlock(\"span\", {\n    key: 2,\n    class: normalizeClass(_ctx.nsInput.e(\"suffix\"))\n  }, [createElementVNode(\"span\", {\n    class: normalizeClass(_ctx.nsInput.e(\"suffix-inner\"))\n  }, [!_ctx.showClear || !_ctx.showPwdVisible || !_ctx.isWordLimitVisible ? (openBlock(), createElementBlock(Fragment, {\n    key: 0\n  }, [renderSlot(_ctx.$slots, \"suffix\"), _ctx.suffixIcon ? (openBlock(), createBlock(_component_el_icon, {\n    key: 0,\n    class: normalizeClass(_ctx.nsInput.e(\"icon\"))\n  }, {\n    default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))]),\n    _: 1\n  }, 8, [\"class\"])) : createCommentVNode(\"v-if\", true)], 64)) : createCommentVNode(\"v-if\", true), _ctx.showClear ? (openBlock(), createBlock(_component_el_icon, {\n    key: 1,\n    class: normalizeClass([_ctx.nsInput.e(\"icon\"), _ctx.nsInput.e(\"clear\")]),\n    onMousedown: _cache[8] || (_cache[8] = withModifiers(() => {}, [\"prevent\"])),\n    onClick: _ctx.clear\n  }, {\n    default: withCtx(() => [createVNode(_component_circle_close)]),\n    _: 1\n  }, 8, [\"class\", \"onClick\"])) : createCommentVNode(\"v-if\", true), _ctx.showPwdVisible ? (openBlock(), createBlock(_component_el_icon, {\n    key: 2,\n    class: normalizeClass([_ctx.nsInput.e(\"icon\"), _ctx.nsInput.e(\"clear\")]),\n    onClick: _ctx.handlePasswordVisible\n  }, {\n    default: withCtx(() => [createVNode(_component_icon_view)]),\n    _: 1\n  }, 8, [\"class\", \"onClick\"])) : createCommentVNode(\"v-if\", true), _ctx.isWordLimitVisible ? (openBlock(), createElementBlock(\"span\", {\n    key: 3,\n    class: normalizeClass(_ctx.nsInput.e(\"count\"))\n  }, [createElementVNode(\"span\", {\n    class: normalizeClass(_ctx.nsInput.e(\"count-inner\"))\n  }, toDisplayString(_ctx.textLength) + \" / \" + toDisplayString(_ctx.attrs.maxlength), 3)], 2)) : createCommentVNode(\"v-if\", true)], 2), _ctx.validateState && _ctx.validateIcon && _ctx.needStatusIcon ? (openBlock(), createBlock(_component_el_icon, {\n    key: 0,\n    class: normalizeClass([_ctx.nsInput.e(\"icon\"), _ctx.nsInput.e(\"validateIcon\")])\n  }, {\n    default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))]),\n    _: 1\n  }, 8, [\"class\"])) : createCommentVNode(\"v-if\", true)], 2)) : createCommentVNode(\"v-if\", true), createCommentVNode(\" append slot \"), _ctx.$slots.append ? (openBlock(), createElementBlock(\"div\", {\n    key: 3,\n    class: normalizeClass(_ctx.nsInput.be(\"group\", \"append\"))\n  }, [renderSlot(_ctx.$slots, \"append\")], 2)) : createCommentVNode(\"v-if\", true)], 64)) : (openBlock(), createElementBlock(Fragment, {\n    key: 1\n  }, [createCommentVNode(\" textarea \"), createElementVNode(\"textarea\", mergeProps({\n    ref: \"textarea\",\n    class: _ctx.nsTextarea.e(\"inner\")\n  }, _ctx.attrs, {\n    tabindex: _ctx.tabindex,\n    disabled: _ctx.inputDisabled,\n    readonly: _ctx.readonly,\n    autocomplete: _ctx.autocomplete,\n    style: _ctx.computedTextareaStyle,\n    \"aria-label\": _ctx.label,\n    placeholder: _ctx.placeholder,\n    onCompositionstart: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),\n    onCompositionupdate: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),\n    onCompositionend: _cache[11] || (_cache[11] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),\n    onInput: _cache[12] || (_cache[12] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),\n    onFocus: _cache[13] || (_cache[13] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),\n    onBlur: _cache[14] || (_cache[14] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),\n    onChange: _cache[15] || (_cache[15] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),\n    onKeydown: _cache[16] || (_cache[16] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))\n  }), null, 16, _hoisted_2), _ctx.isWordLimitVisible ? (openBlock(), createElementBlock(\"span\", {\n    key: 0,\n    class: normalizeClass(_ctx.nsInput.e(\"count\"))\n  }, toDisplayString(_ctx.textLength) + \" / \" + toDisplayString(_ctx.attrs.maxlength), 3)) : createCommentVNode(\"v-if\", true)], 64))], 38)), [[vShow, _ctx.type !== \"hidden\"]]);\n}\n\nvar Input = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { Input as default };","map":null,"metadata":{},"sourceType":"module"}