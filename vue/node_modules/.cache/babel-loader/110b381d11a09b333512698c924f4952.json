{"ast":null,"code":"import { defineComponent, ref, computed, resolveComponent, openBlock, createBlock, withCtx, resolveDynamicComponent, createCommentVNode, createElementBlock, Fragment, renderList } from 'vue';\nimport dayjs from 'dayjs';\nimport customParseFormat from 'dayjs/plugin/customParseFormat';\nimport { ElSelect } from '../../select/index.mjs';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { Clock, CircleClose } from '@element-plus/icons-vue';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\ndayjs.extend(customParseFormat);\nconst {\n  Option: ElOption\n} = ElSelect;\n\nconst parseTime = time => {\n  const values = (time || \"\").split(\":\");\n\n  if (values.length >= 2) {\n    let hours = parseInt(values[0], 10);\n    const minutes = parseInt(values[1], 10);\n    const timeUpper = time.toUpperCase();\n\n    if (timeUpper.includes(\"AM\") && hours === 12) {\n      hours = 0;\n    } else if (timeUpper.includes(\"PM\") && hours !== 12) {\n      hours += 12;\n    }\n\n    return {\n      hours,\n      minutes\n    };\n  }\n\n  return null;\n};\n\nconst compareTime = (time1, time2) => {\n  const value1 = parseTime(time1);\n  const value2 = parseTime(time2);\n  const minutes1 = value1.minutes + value1.hours * 60;\n  const minutes2 = value2.minutes + value2.hours * 60;\n\n  if (minutes1 === minutes2) {\n    return 0;\n  }\n\n  return minutes1 > minutes2 ? 1 : -1;\n};\n\nconst padTime = time => {\n  return `${time}`.padStart(2, \"0\");\n};\n\nconst formatTime = time => {\n  return `${padTime(time.hours)}:${padTime(time.minutes)}`;\n};\n\nconst nextTime = (time, step) => {\n  const timeValue = parseTime(time);\n  const stepValue = parseTime(step);\n  const next = {\n    hours: timeValue.hours,\n    minutes: timeValue.minutes\n  };\n  next.minutes += stepValue.minutes;\n  next.hours += stepValue.hours;\n  next.hours += Math.floor(next.minutes / 60);\n  next.minutes = next.minutes % 60;\n  return formatTime(next);\n};\n\nconst _sfc_main = defineComponent({\n  name: \"ElTimeSelect\",\n  components: {\n    ElSelect,\n    ElOption,\n    ElIcon\n  },\n  model: {\n    prop: \"value\",\n    event: \"change\"\n  },\n  props: {\n    format: {\n      type: String,\n      default: \"HH:mm\"\n    },\n    modelValue: String,\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    editable: {\n      type: Boolean,\n      default: true\n    },\n    effect: {\n      type: String,\n      default: \"light\"\n    },\n    clearable: {\n      type: Boolean,\n      default: true\n    },\n    size: {\n      type: String,\n      default: \"default\",\n      validator: value => !value || [\"large\", \"default\", \"small\"].indexOf(value) !== -1\n    },\n    placeholder: {\n      type: String,\n      default: \"\"\n    },\n    start: {\n      type: String,\n      default: \"09:00\"\n    },\n    end: {\n      type: String,\n      default: \"18:00\"\n    },\n    step: {\n      type: String,\n      default: \"00:30\"\n    },\n    minTime: {\n      type: String,\n      default: \"\"\n    },\n    maxTime: {\n      type: String,\n      default: \"\"\n    },\n    name: {\n      type: String,\n      default: \"\"\n    },\n    prefixIcon: {\n      type: [String, Object],\n      default: Clock\n    },\n    clearIcon: {\n      type: [String, Object],\n      default: CircleClose\n    }\n  },\n  emits: [\"change\", \"blur\", \"focus\", \"update:modelValue\"],\n\n  setup(props) {\n    const select = ref(null);\n    const value = computed(() => props.modelValue);\n    const start = computed(() => {\n      const time = parseTime(props.start);\n      return formatTime(time);\n    });\n    const end = computed(() => {\n      const time = parseTime(props.end);\n      return formatTime(time);\n    });\n    const step = computed(() => {\n      const time = parseTime(props.step);\n      return formatTime(time);\n    });\n    const minTime = computed(() => {\n      const time = parseTime(props.minTime);\n      return time ? formatTime(time) : null;\n    });\n    const maxTime = computed(() => {\n      const time = parseTime(props.maxTime);\n      return time ? formatTime(time) : null;\n    });\n    const items = computed(() => {\n      const result = [];\n\n      if (props.start && props.end && props.step) {\n        let current = start.value;\n        let currentTime;\n\n        while (compareTime(current, end.value) <= 0) {\n          currentTime = dayjs(current, \"HH:mm\").format(props.format);\n          result.push({\n            value: currentTime,\n            disabled: compareTime(current, minTime.value || \"-1:-1\") <= 0 || compareTime(current, maxTime.value || \"100:100\") >= 0\n          });\n          current = nextTime(current, step.value);\n        }\n      }\n\n      return result;\n    });\n\n    const blur = () => {\n      var _a, _b;\n\n      (_b = (_a = select.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);\n    };\n\n    const focus = () => {\n      var _a, _b;\n\n      (_b = (_a = select.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);\n    };\n\n    return {\n      select,\n      value,\n      items,\n      blur,\n      focus\n    };\n  }\n\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_el_option = resolveComponent(\"el-option\");\n\n  const _component_el_icon = resolveComponent(\"el-icon\");\n\n  const _component_el_select = resolveComponent(\"el-select\");\n\n  return openBlock(), createBlock(_component_el_select, {\n    ref: \"select\",\n    \"model-value\": _ctx.value,\n    disabled: _ctx.disabled,\n    clearable: _ctx.clearable,\n    \"clear-icon\": _ctx.clearIcon,\n    size: _ctx.size,\n    effect: _ctx.effect,\n    placeholder: _ctx.placeholder,\n    \"default-first-option\": \"\",\n    filterable: _ctx.editable,\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = event => _ctx.$emit(\"update:modelValue\", event)),\n    onChange: _cache[1] || (_cache[1] = event => _ctx.$emit(\"change\", event)),\n    onBlur: _cache[2] || (_cache[2] = event => _ctx.$emit(\"blur\", event)),\n    onFocus: _cache[3] || (_cache[3] = event => _ctx.$emit(\"focus\", event))\n  }, {\n    prefix: withCtx(() => [_ctx.prefixIcon ? (openBlock(), createBlock(_component_el_icon, {\n      key: 0,\n      class: \"el-input__prefix-icon\"\n    }, {\n      default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))]),\n      _: 1\n    })) : createCommentVNode(\"v-if\", true)]),\n    default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, item => {\n      return openBlock(), createBlock(_component_el_option, {\n        key: item.value,\n        label: item.value,\n        value: item.value,\n        disabled: item.disabled\n      }, null, 8, [\"label\", \"value\", \"disabled\"]);\n    }), 128))]),\n    _: 1\n  }, 8, [\"model-value\", \"disabled\", \"clearable\", \"clear-icon\", \"size\", \"effect\", \"placeholder\", \"filterable\"]);\n}\n\nvar TimeSelect = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { TimeSelect as default };","map":null,"metadata":{},"sourceType":"module"}