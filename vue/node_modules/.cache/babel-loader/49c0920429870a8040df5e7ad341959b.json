{"ast":null,"code":"import { inject, computed, ref, getCurrentInstance, watch } from 'vue';\nimport { toTypeString } from '@vue/shared';\nimport '../../../constants/index.mjs';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { elFormKey, elFormItemKey } from '../../../tokens/form.mjs';\nimport { UPDATE_MODEL_EVENT } from '../../../constants/event.mjs';\nimport { useSize } from '../../../hooks/use-common-props/index.mjs';\nconst useCheckboxProps = {\n  modelValue: {\n    type: [Boolean, Number, String],\n    default: () => void 0\n  },\n  label: {\n    type: [String, Boolean, Number, Object]\n  },\n  indeterminate: Boolean,\n  disabled: Boolean,\n  checked: Boolean,\n  name: {\n    type: String,\n    default: void 0\n  },\n  trueLabel: {\n    type: [String, Number],\n    default: void 0\n  },\n  falseLabel: {\n    type: [String, Number],\n    default: void 0\n  },\n  tabindex: [String, Number],\n  size: String\n};\n\nconst useCheckboxGroup = () => {\n  const elForm = inject(elFormKey, {});\n  const elFormItem = inject(elFormItemKey, {});\n  const checkboxGroup = inject(\"CheckboxGroup\", {});\n  const isGroup = computed(() => checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === \"ElCheckboxGroup\");\n  const elFormItemSize = computed(() => {\n    return elFormItem.size;\n  });\n  return {\n    isGroup,\n    checkboxGroup,\n    elForm,\n    elFormItemSize,\n    elFormItem\n  };\n};\n\nconst useModel = props => {\n  const selfModel = ref(false);\n  const {\n    emit\n  } = getCurrentInstance();\n  const {\n    isGroup,\n    checkboxGroup\n  } = useCheckboxGroup();\n  const isLimitExceeded = ref(false);\n  const model = computed({\n    get() {\n      var _a, _b;\n\n      return isGroup.value ? (_a = checkboxGroup.modelValue) == null ? void 0 : _a.value : (_b = props.modelValue) != null ? _b : selfModel.value;\n    },\n\n    set(val) {\n      var _a;\n\n      if (isGroup.value && Array.isArray(val)) {\n        isLimitExceeded.value = checkboxGroup.max !== void 0 && val.length > checkboxGroup.max.value;\n        isLimitExceeded.value === false && ((_a = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _a.call(checkboxGroup, val));\n      } else {\n        emit(UPDATE_MODEL_EVENT, val);\n        selfModel.value = val;\n      }\n    }\n\n  });\n  return {\n    model,\n    isLimitExceeded\n  };\n};\n\nconst useCheckboxStatus = (props, {\n  model\n}) => {\n  const {\n    isGroup,\n    checkboxGroup\n  } = useCheckboxGroup();\n  const focus = ref(false);\n  const size = useSize(checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize, {\n    prop: true\n  });\n  const isChecked = computed(() => {\n    const value = model.value;\n\n    if (toTypeString(value) === \"[object Boolean]\") {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.includes(props.label);\n    } else if (value !== null && value !== void 0) {\n      return value === props.trueLabel;\n    } else {\n      return !!value;\n    }\n  });\n  const checkboxSize = useSize(computed(() => {\n    var _a;\n\n    return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a.value : void 0;\n  }));\n  return {\n    isChecked,\n    focus,\n    size,\n    checkboxSize\n  };\n};\n\nconst useDisabled = (props, {\n  model,\n  isChecked\n}) => {\n  const {\n    elForm,\n    isGroup,\n    checkboxGroup\n  } = useCheckboxGroup();\n  const isLimitDisabled = computed(() => {\n    var _a, _b;\n\n    const max = (_a = checkboxGroup.max) == null ? void 0 : _a.value;\n    const min = (_b = checkboxGroup.min) == null ? void 0 : _b.value;\n    return !!(max || min) && model.value.length >= max && !isChecked.value || model.value.length <= min && isChecked.value;\n  });\n  const isDisabled = computed(() => {\n    var _a, _b;\n\n    const disabled = props.disabled || elForm.disabled;\n    return (_b = isGroup.value ? ((_a = checkboxGroup.disabled) == null ? void 0 : _a.value) || disabled || isLimitDisabled.value : props.disabled || elForm.disabled) != null ? _b : false;\n  });\n  return {\n    isDisabled,\n    isLimitDisabled\n  };\n};\n\nconst setStoreValue = (props, {\n  model\n}) => {\n  function addToStore() {\n    if (Array.isArray(model.value) && !model.value.includes(props.label)) {\n      model.value.push(props.label);\n    } else {\n      model.value = props.trueLabel || true;\n    }\n  }\n\n  props.checked && addToStore();\n};\n\nconst useEvent = (props, {\n  isLimitExceeded\n}) => {\n  const {\n    elFormItem\n  } = useCheckboxGroup();\n  const {\n    emit\n  } = getCurrentInstance();\n\n  function handleChange(e) {\n    var _a, _b;\n\n    if (isLimitExceeded.value) return;\n    const target = e.target;\n    const value = target.checked ? (_a = props.trueLabel) != null ? _a : true : (_b = props.falseLabel) != null ? _b : false;\n    emit(\"change\", value, e);\n  }\n\n  watch(() => props.modelValue, () => {\n    var _a;\n\n    (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, \"change\");\n  });\n  return {\n    handleChange\n  };\n};\n\nconst useCheckbox = props => {\n  const {\n    model,\n    isLimitExceeded\n  } = useModel(props);\n  const {\n    focus,\n    size,\n    isChecked,\n    checkboxSize\n  } = useCheckboxStatus(props, {\n    model\n  });\n  const {\n    isDisabled\n  } = useDisabled(props, {\n    model,\n    isChecked\n  });\n  const {\n    handleChange\n  } = useEvent(props, {\n    isLimitExceeded\n  });\n  setStoreValue(props, {\n    model\n  });\n  return {\n    isChecked,\n    isDisabled,\n    checkboxSize,\n    model,\n    handleChange,\n    focus,\n    size\n  };\n};\n\nexport { useCheckbox, useCheckboxGroup, useCheckboxProps };","map":null,"metadata":{},"sourceType":"module"}