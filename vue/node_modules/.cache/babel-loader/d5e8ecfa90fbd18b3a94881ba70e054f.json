{"ast":null,"code":"import { defineComponent, inject, ref, getCurrentInstance, computed, watch, nextTick, reactive, toRefs, onMounted, onBeforeUnmount, provide, resolveComponent, openBlock, createElementBlock, normalizeClass, createVNode, withCtx, normalizeStyle, renderSlot, createTextVNode, toDisplayString, createCommentVNode, createElementVNode, Transition } from 'vue';\nimport { NOOP } from '@vue/shared';\nimport AsyncValidator from 'async-validator';\nimport '../../../utils/index.mjs';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport LabelWrap from './label-wrap.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { isValidComponentSize } from '../../../utils/vue/validator.mjs';\nimport { elFormKey, elFormItemKey } from '../../../tokens/form.mjs';\nimport { addUnit } from '../../../utils/vue/style.mjs';\nimport { getPropByPath } from '../../../utils/objects.mjs';\nimport { useSize } from '../../../hooks/use-common-props/index.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"ElFormItem\",\n  componentName: \"ElFormItem\",\n  components: {\n    LabelWrap\n  },\n  props: {\n    label: String,\n    labelWidth: {\n      type: [String, Number],\n      default: \"\"\n    },\n    prop: String,\n    required: {\n      type: Boolean,\n      default: void 0\n    },\n    rules: [Object, Array],\n    error: String,\n    validateStatus: String,\n    for: String,\n    inlineMessage: {\n      type: [String, Boolean],\n      default: \"\"\n    },\n    showMessage: {\n      type: Boolean,\n      default: true\n    },\n    size: {\n      type: String,\n      validator: isValidComponentSize\n    }\n  },\n\n  setup(props, {\n    slots\n  }) {\n    const elForm = inject(elFormKey, {});\n    const validateState = ref(\"\");\n    const validateMessage = ref(\"\");\n    const isValidationEnabled = ref(false);\n    const computedLabelWidth = ref(\"\");\n    const formItemRef = ref();\n    const vm = getCurrentInstance();\n    const isNested = computed(() => {\n      let parent = vm.parent;\n\n      while (parent && parent.type.name !== \"ElForm\") {\n        if (parent.type.name === \"ElFormItem\") {\n          return true;\n        }\n\n        parent = parent.parent;\n      }\n\n      return false;\n    });\n    let initialValue = void 0;\n    watch(() => props.error, val => {\n      validateMessage.value = val;\n      validateState.value = val ? \"error\" : \"\";\n    }, {\n      immediate: true\n    });\n    watch(() => props.validateStatus, val => {\n      validateState.value = val;\n    });\n    const labelFor = computed(() => props.for || props.prop);\n    const labelStyle = computed(() => {\n      const ret = {};\n      if (elForm.labelPosition === \"top\") return ret;\n      const labelWidth = addUnit(props.labelWidth || elForm.labelWidth);\n\n      if (labelWidth) {\n        ret.width = labelWidth;\n      }\n\n      return ret;\n    });\n    const contentStyle = computed(() => {\n      const ret = {};\n\n      if (elForm.labelPosition === \"top\" || elForm.inline) {\n        return ret;\n      }\n\n      if (!props.label && !props.labelWidth && isNested.value) {\n        return ret;\n      }\n\n      const labelWidth = addUnit(props.labelWidth || elForm.labelWidth);\n\n      if (!props.label && !slots.label) {\n        ret.marginLeft = labelWidth;\n      }\n\n      return ret;\n    });\n    const fieldValue = computed(() => {\n      const model = elForm.model;\n\n      if (!model || !props.prop) {\n        return;\n      }\n\n      let path = props.prop;\n\n      if (path.indexOf(\":\") !== -1) {\n        path = path.replace(/:/, \".\");\n      }\n\n      return getPropByPath(model, path, true).v;\n    });\n    const isRequired = computed(() => {\n      const rules = getRules();\n      let required = false;\n\n      if (rules && rules.length) {\n        rules.every(rule => {\n          if (rule.required) {\n            required = true;\n            return false;\n          }\n\n          return true;\n        });\n      }\n\n      return required;\n    });\n    const sizeClass = useSize(void 0, {\n      formItem: false\n    });\n\n    const validate = (trigger, callback = NOOP) => {\n      if (!isValidationEnabled.value) {\n        callback();\n        return;\n      }\n\n      const rules = getFilteredRule(trigger);\n\n      if ((!rules || rules.length === 0) && props.required === void 0) {\n        callback();\n        return;\n      }\n\n      validateState.value = \"validating\";\n      const descriptor = {};\n\n      if (rules && rules.length > 0) {\n        rules.forEach(rule => {\n          delete rule.trigger;\n        });\n      }\n\n      descriptor[props.prop] = rules;\n      const validator = new AsyncValidator(descriptor);\n      const model = {};\n      model[props.prop] = fieldValue.value;\n      validator.validate(model, {\n        firstFields: true\n      }, (errors, fields) => {\n        var _a;\n\n        validateState.value = !errors ? \"success\" : \"error\";\n        validateMessage.value = errors ? errors[0].message || `${props.prop} is required` : \"\";\n        callback(validateMessage.value, errors ? fields : {});\n        (_a = elForm.emit) == null ? void 0 : _a.call(elForm, \"validate\", props.prop, !errors, validateMessage.value || null);\n      });\n    };\n\n    const clearValidate = () => {\n      validateState.value = \"\";\n      validateMessage.value = \"\";\n    };\n\n    const resetField = () => {\n      const model = elForm.model;\n      const value = fieldValue.value;\n      let path = props.prop;\n\n      if (path.indexOf(\":\") !== -1) {\n        path = path.replace(/:/, \".\");\n      }\n\n      const prop = getPropByPath(model, path, true);\n\n      if (Array.isArray(value)) {\n        prop.o[prop.k] = [].concat(initialValue);\n      } else {\n        prop.o[prop.k] = initialValue;\n      }\n\n      nextTick(() => {\n        clearValidate();\n      });\n    };\n\n    const getRules = () => {\n      const formRules = elForm.rules;\n      const selfRules = props.rules;\n      const requiredRule = props.required !== void 0 ? {\n        required: !!props.required\n      } : [];\n      const prop = getPropByPath(formRules, props.prop || \"\", false);\n      const normalizedRule = formRules ? prop.o[props.prop || \"\"] || prop.v : [];\n      return [].concat(selfRules || normalizedRule || []).concat(requiredRule);\n    };\n\n    const getFilteredRule = trigger => {\n      const rules = getRules();\n      return rules.filter(rule => {\n        if (!rule.trigger || trigger === \"\") return true;\n\n        if (Array.isArray(rule.trigger)) {\n          return rule.trigger.indexOf(trigger) > -1;\n        } else {\n          return rule.trigger === trigger;\n        }\n      }).map(rule => ({ ...rule\n      }));\n    };\n\n    const evaluateValidationEnabled = () => {\n      var _a;\n\n      isValidationEnabled.value = !!((_a = getRules()) == null ? void 0 : _a.length);\n    };\n\n    const updateComputedLabelWidth = width => {\n      computedLabelWidth.value = width ? `${width}px` : \"\";\n    };\n\n    const elFormItem = reactive({ ...toRefs(props),\n      size: sizeClass,\n      validateState,\n      $el: formItemRef,\n      evaluateValidationEnabled,\n      resetField,\n      clearValidate,\n      validate,\n      updateComputedLabelWidth\n    });\n    onMounted(() => {\n      if (props.prop) {\n        elForm == null ? void 0 : elForm.addField(elFormItem);\n        const value = fieldValue.value;\n        initialValue = Array.isArray(value) ? [...value] : value;\n        evaluateValidationEnabled();\n      }\n    });\n    onBeforeUnmount(() => {\n      elForm == null ? void 0 : elForm.removeField(elFormItem);\n    });\n    provide(elFormItemKey, elFormItem);\n    const formItemClass = computed(() => [{\n      \"el-form-item--feedback\": elForm.statusIcon,\n      \"is-error\": validateState.value === \"error\",\n      \"is-validating\": validateState.value === \"validating\",\n      \"is-success\": validateState.value === \"success\",\n      \"is-required\": isRequired.value || props.required,\n      \"is-no-asterisk\": elForm.hideRequiredAsterisk\n    }, sizeClass.value ? `el-form-item--${sizeClass.value}` : \"\"]);\n    const shouldShowError = computed(() => {\n      return validateState.value === \"error\" && props.showMessage && elForm.showMessage;\n    });\n    const currentLabel = computed(() => (props.label || \"\") + (elForm.labelSuffix || \"\"));\n    return {\n      formItemRef,\n      formItemClass,\n      shouldShowError,\n      elForm,\n      labelStyle,\n      contentStyle,\n      validateMessage,\n      labelFor,\n      resetField,\n      clearValidate,\n      currentLabel\n    };\n  }\n\n});\n\nconst _hoisted_1 = [\"for\"];\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_LabelWrap = resolveComponent(\"LabelWrap\");\n\n  return openBlock(), createElementBlock(\"div\", {\n    ref: \"formItemRef\",\n    class: normalizeClass([\"el-form-item\", _ctx.formItemClass])\n  }, [createVNode(_component_LabelWrap, {\n    \"is-auto-width\": _ctx.labelStyle.width === \"auto\",\n    \"update-all\": _ctx.elForm.labelWidth === \"auto\"\n  }, {\n    default: withCtx(() => [_ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock(\"label\", {\n      key: 0,\n      for: _ctx.labelFor,\n      class: \"el-form-item__label\",\n      style: normalizeStyle(_ctx.labelStyle)\n    }, [renderSlot(_ctx.$slots, \"label\", {\n      label: _ctx.currentLabel\n    }, () => [createTextVNode(toDisplayString(_ctx.currentLabel), 1)])], 12, _hoisted_1)) : createCommentVNode(\"v-if\", true)]),\n    _: 3\n  }, 8, [\"is-auto-width\", \"update-all\"]), createElementVNode(\"div\", {\n    class: \"el-form-item__content\",\n    style: normalizeStyle(_ctx.contentStyle)\n  }, [renderSlot(_ctx.$slots, \"default\"), createVNode(Transition, {\n    name: \"el-zoom-in-top\"\n  }, {\n    default: withCtx(() => [_ctx.shouldShowError ? renderSlot(_ctx.$slots, \"error\", {\n      key: 0,\n      error: _ctx.validateMessage\n    }, () => [createElementVNode(\"div\", {\n      class: normalizeClass([\"el-form-item__error\", {\n        \"el-form-item__error--inline\": typeof _ctx.inlineMessage === \"boolean\" ? _ctx.inlineMessage : _ctx.elForm.inlineMessage || false\n      }])\n    }, toDisplayString(_ctx.validateMessage), 3)]) : createCommentVNode(\"v-if\", true)]),\n    _: 3\n  })], 4)], 2);\n}\n\nvar FormItem = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { FormItem as default };","map":null,"metadata":{},"sourceType":"module"}